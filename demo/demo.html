<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link href="demo.css" rel="stylesheet">
    <script src="demo.js" type="text/javascript"></script>
    <script src="modelDrawer.js" type="text/javascript"></script>
    <script src="objmesh.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="uiContainer">
    <div id="ui">
    </div>
</div>
<!-- vertex shader -->
<script id="vertex-shader-3d" type="x-shader/x-vertex">
    attribute vec4 a_position;
    attribute vec2 a_texcoord;

    uniform mat4 u_projection;
    uniform mat4 u_view;
    uniform mat4 u_world;
    uniform mat4 u_textureMatrix;

    varying vec2 v_texcoord;
    varying vec4 v_projectedTexcoord;

    void main() {
        // Multiply the position by the matrix.
        vec4 worldPosition = u_world * a_position;

        gl_Position = u_projection * u_view * worldPosition;

        // Pass the texture coord to the fragment shader.
        v_texcoord = a_texcoord;

        v_projectedTexcoord = u_textureMatrix * worldPosition;
    }
</script>
<!-- fragment shader -->
<script id="fragment-shader-3d" type="x-shader/x-fragment">
    precision mediump float;

    // Passed in from the vertex shader.
    varying vec2 v_texcoord;
    varying vec4 v_projectedTexcoord;

    uniform vec4 u_colorMult;
    uniform sampler2D u_texture;
    uniform sampler2D u_projectedTexture;

    void main() {
        vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
        bool inRange =
        projectedTexcoord.x >= 0.0 &&
        projectedTexcoord.x <= 1.0 &&
        projectedTexcoord.y >= 0.0 &&
        projectedTexcoord.y <= 1.0;
        vec4 projectedTexColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
        vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
        float projectedAmount = inRange ? 1.0 : 0.0;
        gl_FragColor = mix(texColor, projectedTexColor, projectedAmount);
    }
</script>
<!-- vertex shader -->
<script id="color-vertex-shader" type="x-shader/x-vertex">
    attribute vec3 pos;
    uniform mat4 objectMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    void main() {
        // Multiply the position by the matrices.
        gl_Position = projectionMatrix * viewMatrix * objectMatrix * vec4(pos, 1);
    }
</script>
<!-- fragment shader -->
<script id="color-fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    void main() {
        gl_FragColor = vec4(gl_FragCoord.x, 1.0 - gl_FragCoord.x, gl_FragCoord.z, 1.0);
    }
</script>
<script id="vertex-shader-toon" type="x-shader/x-vertex">
    attribute vec3 pos;
    attribute vec2 texPos;
    attribute vec3 normPos;

    uniform mat4 objectMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat4 invertida;
    uniform mat4 u_textureMatrix;
    // uniform vec3 l;
    varying vec2 texCoord;
    varying vec3 normCoord;
    varying vec4 vertCoord;
    varying vec4 vecMV;
    varying vec4 v_projectedTexcoord;

    void main()
    {
        vecMV = viewMatrix * objectMatrix * vec4(pos, 1);
        gl_Position = projectionMatrix * vecMV;
        vertCoord = vec4(pos, 1);
        texCoord = texPos;
        normCoord = mat3(objectMatrix) * normPos;
        v_projectedTexcoord = u_textureMatrix * objectMatrix * vec4(pos, 1);
    }
</script>
<!-- fragment shader -->
<script id="fragment-shader-toon" type="x-shader/x-fragment">
    precision mediump float;
    uniform mat3 mn;
    uniform vec3 l;
    uniform float bias;

    varying vec2 texCoord;
    varying vec3 normCoord;
    varying vec4 vertCoord;
    varying vec4 vecMV;
    varying vec4 v_projectedTexcoord;

    uniform float mostrar;
    uniform float cargada;
    uniform float shininess;
    uniform sampler2D color;
    uniform sampler2D u_projectedTexture;

    void main()
    {
        float luzNormal = dot(l, normCoord);

        vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
        float currentDepth = projectedTexcoord.z + bias;

        bool inRange =
        projectedTexcoord.x >= 0.0 &&
        projectedTexcoord.x <= 1.0 &&
        projectedTexcoord.y >= 0.0 &&
        projectedTexcoord.y <= 1.0;

        // the 'r' channel has the depth values
        vec4 frame = texture2D(u_projectedTexture, projectedTexcoord.xy);
        float projectedDepth = frame.r;
        float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;

        vec3 vista = vec3(-vecMV[0], -vecMV[1], -vecMV[2]);
        vec4 textureColor = texture2D(color, texCoord);
        vec4 ks = vec4(0.8, 0.8, 0.8, 1.0);
        vec3 h = normalize(l + normalize(vista));
        float vistaR = dot(h, normalize(normCoord));

//        luzNormal = smoothstep(0.0, 0.01, luzNormal) + 0.1;
        luzNormal =  luzNormal > 0.4 ? 1.0 : 0.0;
        luzNormal =  luzNormal * shadowLight;
        vec4 diffuseColor = (mostrar != 0.0 && cargada == 1.0) ? textureColor : vec4(0.2, 0.8, 0.1, 1.0);//vec4(1.0,0.0,gl_FragCoord.z*gl_FragCoord.z,1.0);

        //Primero est√° el aura solida en los bordes
        float sauronDot = 1.0 - dot(normalize(vista), normalize(normCoord));
        //float sauronIntenso = smoothstep(0.716 - 0.01, 0.716 + 0.01, sauronDot);

        //Esta aura apareciendo solamente en el area iluminada
        float sauronIntenso = sauronDot * luzNormal;
        sauronIntenso = smoothstep(0.716 - 0.05, 0.716 + 0.05, sauronIntenso);

        //Aura tranca, blend
        //                sauronIntenso = sauronDot * pow(luzNormal, 0.1);
        //Primer termino es la luz ambiental
        gl_FragColor =  (diffuseColor * vec4(0.1, 0.1, 0.1, 1.0) + luzNormal  * (diffuseColor + ks * smoothstep(0.005, 0.01, pow(max(0.0, vistaR), shininess)) / luzNormal)) + vec4(0.5, 0.5, 0.5, 1.0) * sauronIntenso;
//        gl_FragColor = vec4(shadowLight,shadowLight,shadowLight, 1.0);
        //        gl_FragColor = vec4(gl_FragCoord.x, 1.0 - gl_FragCoord.x, gl_FragCoord.z, 1.0);

    }
</script>

</body>

</html>
