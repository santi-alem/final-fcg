<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link href="demo.css" rel="stylesheet">
    <script src="demo.js" type="text/javascript"></script>
    <script src="modelDrawer.js" type="text/javascript"></script>
    <script src="objmesh.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="uiContainer">
    <div id="ui">
    </div>
</div>
<!-- vertex shader -->
<script id="color-vertex-shader" type="x-shader/x-vertex">
    attribute vec3 pos;
    uniform mat4 objectMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    void main() {
        // Multiply the position by the matrices.
        gl_Position = projectionMatrix * viewMatrix * objectMatrix * vec4(pos, 1);
    }
</script>
<!-- fragment shader -->
<script id="color-fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    void main() {
        gl_FragColor = vec4(gl_FragCoord.x, 1.0 - gl_FragCoord.x, gl_FragCoord.z, 1.0);
    }
</script>
<script id="vertex-shader-toon" type="x-shader/x-vertex">
    attribute vec3 pos;
    attribute vec2 texPos;
    attribute vec3 normPos;

    uniform mat4 objectMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat4 invertida;
    uniform mat4 u_textureMatrix;
    // uniform vec3 l;
    varying vec2 texCoord;
    varying vec3 normCoord;
    varying vec3 normShadowCoord;
    varying vec4 vertCoord;
    varying vec4 vecMV;
    varying vec4 v_projectedTexcoord;

    void main()
    {
        vecMV = viewMatrix * objectMatrix * vec4(pos, 1);
        gl_Position = projectionMatrix * vecMV;
        vertCoord = vec4(pos, 1);
        texCoord = texPos;
        normCoord = mat3(viewMatrix * objectMatrix) * normPos;
        normShadowCoord = mat3(objectMatrix) * normPos;
        v_projectedTexcoord = u_textureMatrix * objectMatrix * vec4(pos, 1);
    }
</script>
<!-- fragment shader -->
<script id="fragment-shader-toon" type="x-shader/x-fragment">
        precision mediump float;
        uniform mat3 mn;
        uniform vec3 l;
        uniform float bias;
        uniform float tipoLuz;

    varying vec2 texCoord;
    varying vec3 normCoord;
    varying vec3 normShadowCoord;
    varying vec4 vertCoord;
    varying vec4 vecMV;
    varying vec4 v_projectedTexcoord;

        uniform float mostrar;
        uniform float cargada;
        uniform float shininess;
        uniform sampler2D color;
        uniform sampler2D u_projectedTexture;

    void main()
    {
            float luzNormal = dot(l, normShadowCoord);
            float shinyLight = dot(l, normCoord);

            vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
            float currentDepth = projectedTexcoord.z + bias;

            bool inRange =
            projectedTexcoord.x >= 0.0 &&
            projectedTexcoord.x <= 1.0 &&
            projectedTexcoord.y >= 0.0 &&
            projectedTexcoord.y <= 1.0;

            // the 'r' channel has the depth values
            vec4 frame = texture2D(u_projectedTexture, projectedTexcoord.xy);
            float projectedDepth = frame.r;
            float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;

            vec3 vista = vec3(-vecMV[0], -vecMV[1], -vecMV[2]);
            vec4 textureColor = texture2D(color, texCoord);
            vec4 ks = vec4(0.8, 0.8, 0.8, 1.0);
            vec3 h = normalize(l + normalize(vista));
            float vistaR = dot(h, normalize(normShadowCoord)) * 0.4 + dot(h, normalize(normCoord)) * 0.6;

    //        luzNormal = smoothstep(0.0, 0.01, luzNormal) + 0.1;
            luzNormal =  (luzNormal > 0.4 ? 1.0 : 0.0) * tipoLuz + (1.0 - tipoLuz) * (smoothstep(0.0, 0.01, luzNormal) + 0.1);
            luzNormal =  luzNormal * shadowLight;
            vec4 diffuseColor = (mostrar != 0.0 && cargada == 1.0) ? textureColor : vec4(0.2, 0.8, 0.1, 1.0);//vec4(1.0,0.0,gl_FragCoord.z*gl_FragCoord.z,1.0);

            //Primero est√° el aura solida en los bordes
            float sauronDot = 1.0 - dot(normalize(vista), normalize(normCoord));
            //float sauronIntenso = smoothstep(0.716 - 0.01, 0.716 + 0.01, sauronDot);

            //Esta aura apareciendo solamente en el area iluminada
            float sauronIntenso = sauronDot * luzNormal;
            sauronIntenso = smoothstep(0.716 - 0.05, 0.716 + 0.05, sauronIntenso);

            //Aura tranca, blend
            //                sauronIntenso = sauronDot * pow(luzNormal, 0.1);
            //Primer termino es la luz ambiental
            gl_FragColor =  (diffuseColor * vec4(0.1, 0.1, 0.1, 1.0) + luzNormal  * (diffuseColor + ks * smoothstep(0.005, 0.01, pow(max(0.0, vistaR), shininess)) / luzNormal)) + vec4(0.5, 0.5, 0.5, 1.0) * sauronIntenso;
    //        gl_FragColor = vec4(shadowLight,shadowLight,shadowLight, 1.0);
            //        gl_FragColor = vec4(gl_FragCoord.x, 1.0 - gl_FragCoord.x, gl_FragCoord.z, 1.0);

        }
</script>

</body>

</html>
